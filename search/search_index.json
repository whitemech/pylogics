{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PyLogics A Python library for logic formalisms representation and manipulation. Install To install the package from PyPI: pip install pylogics==0.1.0a0 Tests To run tests: tox To run only the code tests: tox -e py3.7 To run only the linters: - tox -e flake8 - tox -e mypy - tox -e black-check - tox -e isort-check Please look at the tox.ini file for the full list of supported commands. Docs To build the docs: mkdocs build To view documentation in a browser: mkdocs serve and then go to http://localhost:8000 License pylogics is released under the GNU Lesser General Public License v3.0 or later (LGPLv3+). Copyright 2021 WhiteMech Authors Marco Favorito","title":"Home"},{"location":"#install","text":"To install the package from PyPI: pip install pylogics==0.1.0a0","title":"Install"},{"location":"#tests","text":"To run tests: tox To run only the code tests: tox -e py3.7 To run only the linters: - tox -e flake8 - tox -e mypy - tox -e black-check - tox -e isort-check Please look at the tox.ini file for the full list of supported commands.","title":"Tests"},{"location":"#docs","text":"To build the docs: mkdocs build To view documentation in a browser: mkdocs serve and then go to http://localhost:8000","title":"Docs"},{"location":"#license","text":"pylogics is released under the GNU Lesser General Public License v3.0 or later (LGPLv3+). Copyright 2021 WhiteMech","title":"License"},{"location":"#authors","text":"Marco Favorito","title":"Authors"},{"location":"grammars/","text":"In this section, all the grammars used by the library are reported here. Propositional Logic The file pl.lark contains the specification of the Lark grammar, and it is reported below: start: propositional_formula ?propositional_formula: prop_equivalence ?prop_equivalence: prop_implication (EQUIVALENCE prop_implication)* ?prop_implication: prop_or (IMPLY prop_or)* ?prop_or: prop_and (OR prop_and)* ?prop_and: prop_not (AND prop_not)* ?prop_not: NOT* prop_wrapped ?prop_wrapped: prop_atom | LSEPARATOR propositional_formula RSEPARATOR ?prop_atom: atom | prop_true | prop_false atom: SYMBOL_NAME prop_true: TRUE prop_false: FALSE LSEPARATOR : \"(\" RSEPARATOR : \")\" EQUIVALENCE : \"<->\" IMPLY : \">>\"|\"->\" OR: \"||\"|\"|\" AND: \"&&\"|\"&\" NOT: \"!\"|\"~\" TRUE.2: /(?i:true)/ FALSE.2: /(?i:false)/ // Symbols cannot contain uppercase letters, because these are reserved // Moreover, any word between quotes is a symbol SYMBOL_NAME: /[a-z][a-z0-9_]*|\"\\w+\"/ %ignore /\\s+/ Linear Temporal Logic The Lark grammar for Linear Temporal Logic is defined in ltl.lark , and it is reported below: start: ltlf_formula ?ltlf_formula: ltlf_equivalence ?ltlf_equivalence: ltlf_implication (EQUIVALENCE ltlf_implication)* ?ltlf_implication: ltlf_or (IMPLY ltlf_or)* ?ltlf_or: ltlf_and (OR ltlf_and)* ?ltlf_and: ltlf_weak_until (AND ltlf_weak_until)* ?ltlf_weak_until: ltlf_until (WEAK_UNTIL ltlf_until)* ?ltlf_until: ltlf_release (UNTIL ltlf_release)* ?ltlf_release: ltlf_strong_release (RELEASE ltlf_strong_release)* ?ltlf_strong_release: ltlf_unaryop (STRONG_RELEASE ltlf_unaryop)* ?ltlf_unaryop: ltlf_always | ltlf_eventually | ltlf_next | ltlf_weak_next | ltlf_not | ltlf_wrapped ?ltlf_always: ALWAYS ltlf_unaryop ?ltlf_eventually: EVENTUALLY ltlf_unaryop ?ltlf_next: NEXT ltlf_unaryop ?ltlf_weak_next: WEAK_NEXT ltlf_unaryop ?ltlf_not: NOT ltlf_unaryop ?ltlf_wrapped: ltlf_atom | LSEPARATOR ltlf_formula RSEPARATOR ?ltlf_atom: ltlf_symbol | ltlf_true | ltlf_false | ltlf_last ltlf_symbol: SYMBOL_NAME ltlf_true: prop_true ltlf_false: prop_false ltlf_last: LAST UNTIL.2: \"U\" RELEASE.2: \"R\" ALWAYS.2: \"G\" EVENTUALLY.2: \"F\" NEXT.2: \"X\" WEAK_NEXT.2: \"N\" WEAK_UNTIL.2: \"W\" STRONG_RELEASE.2: \"M\" END.2: /(?i:end)/ LAST.2: /(?i:last)/ %ignore /\\s+/ %import .pl.SYMBOL_NAME -> SYMBOL_NAME %import .pl.prop_true -> prop_true %import .pl.prop_false -> prop_false %import .pl.NOT -> NOT %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR Past Linear Temporal Logic The Lark grammar for Past Linear Temporal Logic is defined in pltl.lark , and it is reported below: start: pltlf_formula ?pltlf_formula: pltlf_equivalence ?pltlf_equivalence: pltlf_implication (EQUIVALENCE pltlf_implication)* ?pltlf_implication: pltlf_or (IMPLY pltlf_or)* ?pltlf_or: pltlf_and (OR pltlf_and)* ?pltlf_and: pltlf_since (AND pltlf_since)* ?pltlf_since: pltlf_unaryop (SINCE pltlf_unaryop)* ?pltlf_unaryop: pltlf_historically | pltlf_once | pltlf_before | pltlf_not | pltlf_wrapped ?pltlf_historically: HISTORICALLY pltlf_unaryop ?pltlf_once: ONCE pltlf_unaryop ?pltlf_before: BEFORE pltlf_unaryop ?pltlf_not: NOT pltlf_unaryop ?pltlf_wrapped: pltlf_atom | LSEPARATOR pltlf_formula RSEPARATOR ?pltlf_atom: pltlf_symbol | pltlf_true | pltlf_false | pltlf_start pltlf_symbol: SYMBOL_NAME pltlf_true: prop_true pltlf_false: prop_false pltlf_start: START // Operators must not be part of a word SINCE.2: \"S\" HISTORICALLY.2: \"H\" ONCE.2: \"O\" BEFORE.2: \"Y\" START.2: /(?i:start)/ %ignore /\\s+/ %import .pl.SYMBOL_NAME -> SYMBOL_NAME %import .pl.prop_true -> prop_true %import .pl.prop_false -> prop_false %import .pl.NOT -> NOT %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR Linear Dynamic Logic The Lark grammar for Linear Dynamic Logic is defined in ldl.lark , and it is reported below: start: ldlf_formula ?ldlf_formula: ldlf_equivalence ?ldlf_equivalence: ldlf_implication (EQUIVALENCE ldlf_implication)* ?ldlf_implication: ldlf_or (IMPLY ldlf_or)* ?ldlf_or: ldlf_and (OR ldlf_and)* ?ldlf_and: ldlf_unaryop (AND ldlf_unaryop)* ?ldlf_unaryop: ldlf_box | ldlf_diamond | ldlf_not | ldlf_wrapped ?ldlf_box: BOXLSEPARATOR regular_expression BOXRSEPARATOR ldlf_unaryop ?ldlf_diamond: DIAMONDLSEPARATOR regular_expression DIAMONDRSEPARATOR ldlf_unaryop ?ldlf_not: NOT ldlf_unaryop ?ldlf_wrapped: ldlf_atom | LSEPARATOR ldlf_formula RSEPARATOR ?ldlf_atom: ldlf_tt | ldlf_ff | ldlf_last | ldlf_end | ldlf_prop_true | ldlf_prop_false | ldlf_prop_atom ldlf_prop_true: TRUE ldlf_prop_false: FALSE ldlf_prop_atom: SYMBOL_NAME ldlf_tt: TT ldlf_ff: FF ldlf_last: LAST ldlf_end: END regular_expression: re_union ?re_union: re_sequence (UNION re_sequence)* ?re_sequence: re_star (SEQ re_star)* ?re_star: re_test STAR? ?re_test: TEST ldlf_formula | re_wrapped ?re_wrapped: re_propositional | LSEPARATOR regular_expression RSEPARATOR re_propositional: propositional_formula BOXLSEPARATOR: \"[\" BOXRSEPARATOR: \"]\" DIAMONDLSEPARATOR: \"<\" DIAMONDRSEPARATOR: \">\" UNION: \"+\" SEQ: \";\" TEST: \"?\" STAR: \"*\" TT.2: /(?i:tt)/ FF.2: /(?i:ff)/ %ignore /\\s+/ %import .pl.propositional_formula %import .pl.TRUE -> TRUE %import .pl.FALSE -> FALSE %import .pl.SYMBOL_NAME -> SYMBOL_NAME %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.NOT -> NOT %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR %import .ltl.LAST -> LAST %import .ltl.END -> END","title":"Grammars"},{"location":"grammars/#propositional-logic","text":"The file pl.lark contains the specification of the Lark grammar, and it is reported below: start: propositional_formula ?propositional_formula: prop_equivalence ?prop_equivalence: prop_implication (EQUIVALENCE prop_implication)* ?prop_implication: prop_or (IMPLY prop_or)* ?prop_or: prop_and (OR prop_and)* ?prop_and: prop_not (AND prop_not)* ?prop_not: NOT* prop_wrapped ?prop_wrapped: prop_atom | LSEPARATOR propositional_formula RSEPARATOR ?prop_atom: atom | prop_true | prop_false atom: SYMBOL_NAME prop_true: TRUE prop_false: FALSE LSEPARATOR : \"(\" RSEPARATOR : \")\" EQUIVALENCE : \"<->\" IMPLY : \">>\"|\"->\" OR: \"||\"|\"|\" AND: \"&&\"|\"&\" NOT: \"!\"|\"~\" TRUE.2: /(?i:true)/ FALSE.2: /(?i:false)/ // Symbols cannot contain uppercase letters, because these are reserved // Moreover, any word between quotes is a symbol SYMBOL_NAME: /[a-z][a-z0-9_]*|\"\\w+\"/ %ignore /\\s+/","title":"Propositional Logic"},{"location":"grammars/#linear-temporal-logic","text":"The Lark grammar for Linear Temporal Logic is defined in ltl.lark , and it is reported below: start: ltlf_formula ?ltlf_formula: ltlf_equivalence ?ltlf_equivalence: ltlf_implication (EQUIVALENCE ltlf_implication)* ?ltlf_implication: ltlf_or (IMPLY ltlf_or)* ?ltlf_or: ltlf_and (OR ltlf_and)* ?ltlf_and: ltlf_weak_until (AND ltlf_weak_until)* ?ltlf_weak_until: ltlf_until (WEAK_UNTIL ltlf_until)* ?ltlf_until: ltlf_release (UNTIL ltlf_release)* ?ltlf_release: ltlf_strong_release (RELEASE ltlf_strong_release)* ?ltlf_strong_release: ltlf_unaryop (STRONG_RELEASE ltlf_unaryop)* ?ltlf_unaryop: ltlf_always | ltlf_eventually | ltlf_next | ltlf_weak_next | ltlf_not | ltlf_wrapped ?ltlf_always: ALWAYS ltlf_unaryop ?ltlf_eventually: EVENTUALLY ltlf_unaryop ?ltlf_next: NEXT ltlf_unaryop ?ltlf_weak_next: WEAK_NEXT ltlf_unaryop ?ltlf_not: NOT ltlf_unaryop ?ltlf_wrapped: ltlf_atom | LSEPARATOR ltlf_formula RSEPARATOR ?ltlf_atom: ltlf_symbol | ltlf_true | ltlf_false | ltlf_last ltlf_symbol: SYMBOL_NAME ltlf_true: prop_true ltlf_false: prop_false ltlf_last: LAST UNTIL.2: \"U\" RELEASE.2: \"R\" ALWAYS.2: \"G\" EVENTUALLY.2: \"F\" NEXT.2: \"X\" WEAK_NEXT.2: \"N\" WEAK_UNTIL.2: \"W\" STRONG_RELEASE.2: \"M\" END.2: /(?i:end)/ LAST.2: /(?i:last)/ %ignore /\\s+/ %import .pl.SYMBOL_NAME -> SYMBOL_NAME %import .pl.prop_true -> prop_true %import .pl.prop_false -> prop_false %import .pl.NOT -> NOT %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR","title":"Linear Temporal Logic"},{"location":"grammars/#past-linear-temporal-logic","text":"The Lark grammar for Past Linear Temporal Logic is defined in pltl.lark , and it is reported below: start: pltlf_formula ?pltlf_formula: pltlf_equivalence ?pltlf_equivalence: pltlf_implication (EQUIVALENCE pltlf_implication)* ?pltlf_implication: pltlf_or (IMPLY pltlf_or)* ?pltlf_or: pltlf_and (OR pltlf_and)* ?pltlf_and: pltlf_since (AND pltlf_since)* ?pltlf_since: pltlf_unaryop (SINCE pltlf_unaryop)* ?pltlf_unaryop: pltlf_historically | pltlf_once | pltlf_before | pltlf_not | pltlf_wrapped ?pltlf_historically: HISTORICALLY pltlf_unaryop ?pltlf_once: ONCE pltlf_unaryop ?pltlf_before: BEFORE pltlf_unaryop ?pltlf_not: NOT pltlf_unaryop ?pltlf_wrapped: pltlf_atom | LSEPARATOR pltlf_formula RSEPARATOR ?pltlf_atom: pltlf_symbol | pltlf_true | pltlf_false | pltlf_start pltlf_symbol: SYMBOL_NAME pltlf_true: prop_true pltlf_false: prop_false pltlf_start: START // Operators must not be part of a word SINCE.2: \"S\" HISTORICALLY.2: \"H\" ONCE.2: \"O\" BEFORE.2: \"Y\" START.2: /(?i:start)/ %ignore /\\s+/ %import .pl.SYMBOL_NAME -> SYMBOL_NAME %import .pl.prop_true -> prop_true %import .pl.prop_false -> prop_false %import .pl.NOT -> NOT %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR","title":"Past Linear Temporal Logic"},{"location":"grammars/#linear-dynamic-logic","text":"The Lark grammar for Linear Dynamic Logic is defined in ldl.lark , and it is reported below: start: ldlf_formula ?ldlf_formula: ldlf_equivalence ?ldlf_equivalence: ldlf_implication (EQUIVALENCE ldlf_implication)* ?ldlf_implication: ldlf_or (IMPLY ldlf_or)* ?ldlf_or: ldlf_and (OR ldlf_and)* ?ldlf_and: ldlf_unaryop (AND ldlf_unaryop)* ?ldlf_unaryop: ldlf_box | ldlf_diamond | ldlf_not | ldlf_wrapped ?ldlf_box: BOXLSEPARATOR regular_expression BOXRSEPARATOR ldlf_unaryop ?ldlf_diamond: DIAMONDLSEPARATOR regular_expression DIAMONDRSEPARATOR ldlf_unaryop ?ldlf_not: NOT ldlf_unaryop ?ldlf_wrapped: ldlf_atom | LSEPARATOR ldlf_formula RSEPARATOR ?ldlf_atom: ldlf_tt | ldlf_ff | ldlf_last | ldlf_end | ldlf_prop_true | ldlf_prop_false | ldlf_prop_atom ldlf_prop_true: TRUE ldlf_prop_false: FALSE ldlf_prop_atom: SYMBOL_NAME ldlf_tt: TT ldlf_ff: FF ldlf_last: LAST ldlf_end: END regular_expression: re_union ?re_union: re_sequence (UNION re_sequence)* ?re_sequence: re_star (SEQ re_star)* ?re_star: re_test STAR? ?re_test: TEST ldlf_formula | re_wrapped ?re_wrapped: re_propositional | LSEPARATOR regular_expression RSEPARATOR re_propositional: propositional_formula BOXLSEPARATOR: \"[\" BOXRSEPARATOR: \"]\" DIAMONDLSEPARATOR: \"<\" DIAMONDRSEPARATOR: \">\" UNION: \"+\" SEQ: \";\" TEST: \"?\" STAR: \"*\" TT.2: /(?i:tt)/ FF.2: /(?i:ff)/ %ignore /\\s+/ %import .pl.propositional_formula %import .pl.TRUE -> TRUE %import .pl.FALSE -> FALSE %import .pl.SYMBOL_NAME -> SYMBOL_NAME %import .pl.EQUIVALENCE -> EQUIVALENCE %import .pl.IMPLY -> IMPLY %import .pl.OR -> OR %import .pl.AND -> AND %import .pl.NOT -> NOT %import .pl.LSEPARATOR -> LSEPARATOR %import .pl.RSEPARATOR -> RSEPARATOR %import .ltl.LAST -> LAST %import .ltl.END -> END","title":"Linear Dynamic Logic"},{"location":"introduction/","text":"Introduction pylogics is a Python package to parse and manipulate several logic formalisms, with a focus on temporal logics . This library is in early development, and the API might be broken frequently or may contain bugs . Docs are not thorough and might be inaccurate. Apologizes. Quickstart For example, consider Propositional Logic . The following code allows you to parse a propositional logic formula \\phi = (a \\wedge b) \\vee (c \\wedge d) \\phi = (a \\wedge b) \\vee (c \\wedge d) : from pylogics.parsers import parse_pl formula = parse_pl ( \"(a & b) | (c & d)\" ) The object referenced by formula is an instance of Formula . Each instance of Formula is associated with a certain logic formalism. You can read it by accessing the logic attribute: formlua.logic which returns an instance of the Enum class pylogics.syntax.base.Logic . We can evaluate the formula on a propositional interpretation. First, import the function evaluate_pl : from pylogics.semantics.pl import evaluate_pl evaluate_pl takes in input an instance of Formula , with formula.logic equal to Logic.PL , and a propositional interpretation I I in the form of a set of strings or a dictionary from strings to booleans. when a set is given, each symbol in the set is considered true; if not, it is considered false. when a dictionary is given, the value of the symbol in the model is determined by the boolean value in the dictionary associated to that key. If the key is not present, it is assumed to be false. For example, say we want to evaluate the formula over the model \\mathcal{I}_1 = \\{a\\} \\mathcal{I}_1 = \\{a\\} . We have \\mathcal{I}_1 \\not\\models \\phi \\mathcal{I}_1 \\not\\models \\phi : evaluate_pl ( formula , { 'a' }) # returns False Now consider \\mathcal{I}_2 = \\{a, b\\} \\mathcal{I}_2 = \\{a, b\\} . We have \\mathcal{I}_2 \\models \\phi \\mathcal{I}_2 \\models \\phi : evaluate_pl ( formula , { 'a' , 'b' }) # returns True Alternatively, we could have written: evaluate_pl ( formula , { 'a' : True , 'b' : True , 'c' : False }) # returns True The value for d is assumed to be false, since it is not in the dictionary. Other logics Currently, the package provides support for: Linear Temporal Logic (on finite traces) ( De Giacomo and Vardi, 2013 , Brafman et al., 2018 ) Past Linear Temporal Logic (on finite traces) (De Giacomo et al., 2020) Linear Dynamic Logic (on finite traces) ( De Giacomo and Vardi, 2013 , Brafman et al., 2018 ) We consider the variants of these formalisms that also works for empty traces; hence (Brafman et al., 2018) is a better reference for the supported logics. More details will be provided in the next sections.","title":"Introduction"},{"location":"introduction/#introduction","text":"pylogics is a Python package to parse and manipulate several logic formalisms, with a focus on temporal logics . This library is in early development, and the API might be broken frequently or may contain bugs . Docs are not thorough and might be inaccurate. Apologizes.","title":"Introduction"},{"location":"introduction/#quickstart","text":"For example, consider Propositional Logic . The following code allows you to parse a propositional logic formula \\phi = (a \\wedge b) \\vee (c \\wedge d) \\phi = (a \\wedge b) \\vee (c \\wedge d) : from pylogics.parsers import parse_pl formula = parse_pl ( \"(a & b) | (c & d)\" ) The object referenced by formula is an instance of Formula . Each instance of Formula is associated with a certain logic formalism. You can read it by accessing the logic attribute: formlua.logic which returns an instance of the Enum class pylogics.syntax.base.Logic . We can evaluate the formula on a propositional interpretation. First, import the function evaluate_pl : from pylogics.semantics.pl import evaluate_pl evaluate_pl takes in input an instance of Formula , with formula.logic equal to Logic.PL , and a propositional interpretation I I in the form of a set of strings or a dictionary from strings to booleans. when a set is given, each symbol in the set is considered true; if not, it is considered false. when a dictionary is given, the value of the symbol in the model is determined by the boolean value in the dictionary associated to that key. If the key is not present, it is assumed to be false. For example, say we want to evaluate the formula over the model \\mathcal{I}_1 = \\{a\\} \\mathcal{I}_1 = \\{a\\} . We have \\mathcal{I}_1 \\not\\models \\phi \\mathcal{I}_1 \\not\\models \\phi : evaluate_pl ( formula , { 'a' }) # returns False Now consider \\mathcal{I}_2 = \\{a, b\\} \\mathcal{I}_2 = \\{a, b\\} . We have \\mathcal{I}_2 \\models \\phi \\mathcal{I}_2 \\models \\phi : evaluate_pl ( formula , { 'a' , 'b' }) # returns True Alternatively, we could have written: evaluate_pl ( formula , { 'a' : True , 'b' : True , 'c' : False }) # returns True The value for d is assumed to be false, since it is not in the dictionary.","title":"Quickstart"},{"location":"introduction/#other-logics","text":"Currently, the package provides support for: Linear Temporal Logic (on finite traces) ( De Giacomo and Vardi, 2013 , Brafman et al., 2018 ) Past Linear Temporal Logic (on finite traces) (De Giacomo et al., 2020) Linear Dynamic Logic (on finite traces) ( De Giacomo and Vardi, 2013 , Brafman et al., 2018 ) We consider the variants of these formalisms that also works for empty traces; hence (Brafman et al., 2018) is a better reference for the supported logics. More details will be provided in the next sections.","title":"Other logics"},{"location":"parsing/","text":"One of the core features of the library is the support of parsing strings compliant to a certain grammar to handily build formulae. The parsing functions, one for each logic formalism, can be imported from pylogics.parsers , and their name is parse_<id> , where <id> is the identifier of the logic formalism. For example, the parsing for propositional logic ( pl ) is parse_pl , whereas the parsing function for Linear Temporal Logic ( ltl ) is parse_ltl . For a list of the supported logics and their identifier please look at this page . The library uses Lark to generate the parser automatically. The grammar files are reported at this page . Symbols A symbol is determined by the following regular expression: SYMBOL: [a-z][a-z0-9_]*|\"\\w+\" That is: if between quotes \"\" , a symbol can be any non-empty sequence of word characters: [a-zA-Z0-9_]+ if not, a symbol must: have only have lower case characters have at least one character and start with a non-digit character. Propositional Logic Informally, the supported grammar for propositional logic is: pl_formula: pl_formula <-> pl_formula // equivalence | pl_formula -> pl_formula // implication | pl_formula || pl_formula // disjunction | pl_formula && pl_formula // conjunction | !pl_formula // negation | ( pl_formula ) // brackets | true // boolean constant | false // boolean constant | SYMBOL // prop. atom Some examples: from pylogics.parsers import parse_pl parse_pl ( \"a\" ) parse_pl ( \"b\" ) parse_pl ( \"a & b\" ) parse_pl ( \"a | b\" ) parse_pl ( \"a >> b\" ) parse_pl ( \"a <-> b\" ) parse_pl ( \"a <-> a\" ) # returns a parse_pl ( \"!(a)\" ) parse_pl ( \"true | false\" ) # returns true parse_pl ( \"true & false\" ) # returns false Linear Temporal Logic Informally, the supported grammar for linear temporal logic is: ltl_formula: ltl_formula <-> ltl_formula // equivalence | ltl_formula -> ltl_formula // implication | ltl_formula || ltl_formula // disjunction | ltl_formula && ltl_formula // conjunction | !ltl_formula // negation | ( ltl_formula ) // brackets | ltl_formula U ltl_formula // until | ltl_formula R ltl_formula // release | ltl_formula W ltl_formula // weak until | ltl_formula M ltl_formula // strong release | F ltl_formula // eventually | G ltl_formula // always | X ltl_formula // next | N ltl_formula // weak next | true // boolean constant | false // boolean constant | SYMBOL // prop. atom Some examples: from pylogics.parsers import parse_ltl parse_ltl ( \"a\" ) parse_ltl ( \"b\" ) parse_ltl ( \"X(a)\" ) parse_ltl ( \"N(b)\" ) parse_ltl ( \"F(a)\" ) parse_ltl ( \"G(b)\" ) parse_ltl ( \"G(a -> b)\" ) parse_ltl ( \"a U b\" ) parse_ltl ( \"a R b\" ) parse_ltl ( \"a W b\" ) parse_ltl ( \"a M b\" ) Past Linear Temporal Logic Informally, the supported grammar for past linear temporal logic is: pltl_formula: pltl_formula <-> pltl_formula // equivalence | pltl_formula -> pltl_formula // implication | pltl_formula || pltl_formula // disjunction | pltl_formula && pltl_formula // conjunction | !pltl_formula // negation | ( pltl_formula ) // brackets | pltl_formula S pltl_formula // since | H pltl_formula // historically | O pltl_formula // once | Y pltl_formula // before | true // boolean constant | false // boolean constant | SYMBOL // prop. atom Some examples: from pylogics.parsers import parse_pltl parse_pltl ( \"a\" ) parse_pltl ( \"b\" ) parse_pltl ( \"Y(a)\" ) parse_pltl ( \"O(b)\" ) parse_pltl ( \"H(a)\" ) parse_pltl ( \"a S b\" ) Linear Dynamic Logic Informally, the supported grammar for linear dynamic logic is (note; it is doubly-inductive): ldl_formula: ldl_formula <-> ldl_formula // equivalence | ldl_formula -> ldl_formula // implication | ldl_formula || ldl_formula // disjunction | ldl_formula && ldl_formula // conjunction | !ldl_formula // negation | ( ldl_formula ) // brackets | <regex>ldl_formula // diamond formula | [regex]ldl_formula // box formula | tt // boolean constant | ff // boolean constant regex : regex + regex // union | regex ; regex // sequence | ?regex // test | regex* // star | pl_formula // prop. formula (see above) Note: the question mark in the test regular expression is on the left, not on the right. This is done to avoid parse conflicts in the parser generation. Some examples: from pylogics.parsers import parse_ldl parse_ldl ( \"tt\" ) parse_ldl ( \"ff\" ) parse_ldl ( \"<a>tt\" ) parse_ldl ( \"[a & b]ff\" ) parse_ldl ( \"<a + b>tt\" ) parse_ldl ( \"<a ; b><c>tt\" ) parse_ldl ( \"<(a ; b)*><c>tt\" ) parse_ldl ( \"<true><a>tt\" ) # Next a parse_ldl ( \"<(?<a>tt;true)*>(<b>tt)\" ) # (a Until b) in LDLf","title":"Parsing"},{"location":"parsing/#symbols","text":"A symbol is determined by the following regular expression: SYMBOL: [a-z][a-z0-9_]*|\"\\w+\" That is: if between quotes \"\" , a symbol can be any non-empty sequence of word characters: [a-zA-Z0-9_]+ if not, a symbol must: have only have lower case characters have at least one character and start with a non-digit character.","title":"Symbols"},{"location":"parsing/#propositional-logic","text":"Informally, the supported grammar for propositional logic is: pl_formula: pl_formula <-> pl_formula // equivalence | pl_formula -> pl_formula // implication | pl_formula || pl_formula // disjunction | pl_formula && pl_formula // conjunction | !pl_formula // negation | ( pl_formula ) // brackets | true // boolean constant | false // boolean constant | SYMBOL // prop. atom Some examples: from pylogics.parsers import parse_pl parse_pl ( \"a\" ) parse_pl ( \"b\" ) parse_pl ( \"a & b\" ) parse_pl ( \"a | b\" ) parse_pl ( \"a >> b\" ) parse_pl ( \"a <-> b\" ) parse_pl ( \"a <-> a\" ) # returns a parse_pl ( \"!(a)\" ) parse_pl ( \"true | false\" ) # returns true parse_pl ( \"true & false\" ) # returns false","title":"Propositional Logic"},{"location":"parsing/#linear-temporal-logic","text":"Informally, the supported grammar for linear temporal logic is: ltl_formula: ltl_formula <-> ltl_formula // equivalence | ltl_formula -> ltl_formula // implication | ltl_formula || ltl_formula // disjunction | ltl_formula && ltl_formula // conjunction | !ltl_formula // negation | ( ltl_formula ) // brackets | ltl_formula U ltl_formula // until | ltl_formula R ltl_formula // release | ltl_formula W ltl_formula // weak until | ltl_formula M ltl_formula // strong release | F ltl_formula // eventually | G ltl_formula // always | X ltl_formula // next | N ltl_formula // weak next | true // boolean constant | false // boolean constant | SYMBOL // prop. atom Some examples: from pylogics.parsers import parse_ltl parse_ltl ( \"a\" ) parse_ltl ( \"b\" ) parse_ltl ( \"X(a)\" ) parse_ltl ( \"N(b)\" ) parse_ltl ( \"F(a)\" ) parse_ltl ( \"G(b)\" ) parse_ltl ( \"G(a -> b)\" ) parse_ltl ( \"a U b\" ) parse_ltl ( \"a R b\" ) parse_ltl ( \"a W b\" ) parse_ltl ( \"a M b\" )","title":"Linear Temporal Logic"},{"location":"parsing/#past-linear-temporal-logic","text":"Informally, the supported grammar for past linear temporal logic is: pltl_formula: pltl_formula <-> pltl_formula // equivalence | pltl_formula -> pltl_formula // implication | pltl_formula || pltl_formula // disjunction | pltl_formula && pltl_formula // conjunction | !pltl_formula // negation | ( pltl_formula ) // brackets | pltl_formula S pltl_formula // since | H pltl_formula // historically | O pltl_formula // once | Y pltl_formula // before | true // boolean constant | false // boolean constant | SYMBOL // prop. atom Some examples: from pylogics.parsers import parse_pltl parse_pltl ( \"a\" ) parse_pltl ( \"b\" ) parse_pltl ( \"Y(a)\" ) parse_pltl ( \"O(b)\" ) parse_pltl ( \"H(a)\" ) parse_pltl ( \"a S b\" )","title":"Past Linear Temporal Logic"},{"location":"parsing/#linear-dynamic-logic","text":"Informally, the supported grammar for linear dynamic logic is (note; it is doubly-inductive): ldl_formula: ldl_formula <-> ldl_formula // equivalence | ldl_formula -> ldl_formula // implication | ldl_formula || ldl_formula // disjunction | ldl_formula && ldl_formula // conjunction | !ldl_formula // negation | ( ldl_formula ) // brackets | <regex>ldl_formula // diamond formula | [regex]ldl_formula // box formula | tt // boolean constant | ff // boolean constant regex : regex + regex // union | regex ; regex // sequence | ?regex // test | regex* // star | pl_formula // prop. formula (see above) Note: the question mark in the test regular expression is on the left, not on the right. This is done to avoid parse conflicts in the parser generation. Some examples: from pylogics.parsers import parse_ldl parse_ldl ( \"tt\" ) parse_ldl ( \"ff\" ) parse_ldl ( \"<a>tt\" ) parse_ldl ( \"[a & b]ff\" ) parse_ldl ( \"<a + b>tt\" ) parse_ldl ( \"<a ; b><c>tt\" ) parse_ldl ( \"<(a ; b)*><c>tt\" ) parse_ldl ( \"<true><a>tt\" ) # Next a parse_ldl ( \"<(?<a>tt;true)*>(<b>tt)\" ) # (a Until b) in LDLf","title":"Linear Dynamic Logic"},{"location":"references/","text":"References G. De Giacomo and M. Vardi. Linear temporal logic and linear dynamic logic on finite traces. In IJCAI, 2013. R. Brafman, G. De Giacomo, and F. Patrizi. LTLf/LDLf non-markovian rewards. In AAAI, 2018. De Giacomo, G., Di Stasio, A., Fuggitti, F., & Rubin, S. (2020). Pure-Past Linear Temporal and Dynamic Logic on Finite Traces. In IJCAI, 2020.","title":"References"},{"location":"references/#references","text":"G. De Giacomo and M. Vardi. Linear temporal logic and linear dynamic logic on finite traces. In IJCAI, 2013. R. Brafman, G. De Giacomo, and F. Patrizi. LTLf/LDLf non-markovian rewards. In AAAI, 2018. De Giacomo, G., Di Stasio, A., Fuggitti, F., & Rubin, S. (2020). Pure-Past Linear Temporal and Dynamic Logic on Finite Traces. In IJCAI, 2020.","title":"References"},{"location":"supported_logics/","text":"Each logic formalism is associated to a string identifier, to make it easier for the user to navigate the APIs. Follows the table with the supported features for each formal language: Logics Identifier Parsing Syntax Semantics Propositional Logic pl Linear Temporal Logic (fin. traces) ltl Past Linear Temporal Logic (fin. traces) pltl Linear Dynamic Logic (fin. traces) ldl Past Linear Dynamic Logic (fin. traces) pldl First-order Logic fol Monadic Second-order Logic mso","title":"Supported Logics"},{"location":"syntax/","text":"The library can also be used through the syntax APIs. Each class needed to build the syntax tree of a formula of a certain logics is in pylogics.syntax.<id> , where <id> is the logic formalism identifier. See this page for information about the supported formalisms. The basic boolean connectives are defined in pylogics.syntax.base . These are: And Or Not Implies Equivalence The binary operators take in input a sequence of arguments instances of a subclass of Formula . Note that as a precondition the operands. must belong to the same logic formalism E.g. to build a & b a & b , one can do: from pylogics.syntax.pl import Atomic a = Atomic ( \"a\" ) b = Atomic ( \"b\" ) formula = a & b Now formula is an instance of pylogics.syntax.base.And . For the other operators (except equivalence): a | b !a a >> b For true and false , you can use TrueFormula and FalseFormula , respectively: from pylogics.syntax.base import Logic , TrueFormula , FalseFormula true = TrueFormula ( logic = Logic . PL ) false = TrueFormula ( logic = Logic . PL ) Linear Temporal Logic For LTL, you can use the following classes, defined in pylogics.syntax.ltl : Atom , an LTL atom Next (unary operator) WeakNext (unary operator) Until (binary operator) Release (binary operator) WeakUntil (binary operator) StrongRelease (binary operator) Eventually (unary operator) Always (unary operator) To combine the above using boolean connectives, you can use the classes in pylogics.syntax.base described above. Past Linear Temporal Logic For PLTL, you can use the following classes, defined in pylogics.syntax.pltl : Atom , a PLTL atom Before (unary operator) Since (binary operator) Once (unary operator) Historically (unary operator) To combine the above using boolean connectives, you can use the classes in pylogics.syntax.base described above. Linear Dynamic Temporal Logic For LDL, you can use the following classes, defined in pylogics.syntax.ldl : LDLTrue , the boolean positive constant tt LDLFalse , the boolean negative constant ff Diamond(regex, ldlf_formula) Box(regex, ldlf_formula) To combine the above using boolean connectives, you can use the classes in pylogics.syntax.base described above. To build regular expressions: Prop(propositional) , where propositional is a propositional formula (i.e. propositional.logic is Logic.PL ) Union (binary operator) Seq (binary operator) Test(ldlf_formula) (unary operator) Star(regex) (unary operator)","title":"Syntax"},{"location":"syntax/#linear-temporal-logic","text":"For LTL, you can use the following classes, defined in pylogics.syntax.ltl : Atom , an LTL atom Next (unary operator) WeakNext (unary operator) Until (binary operator) Release (binary operator) WeakUntil (binary operator) StrongRelease (binary operator) Eventually (unary operator) Always (unary operator) To combine the above using boolean connectives, you can use the classes in pylogics.syntax.base described above.","title":"Linear Temporal Logic"},{"location":"syntax/#past-linear-temporal-logic","text":"For PLTL, you can use the following classes, defined in pylogics.syntax.pltl : Atom , a PLTL atom Before (unary operator) Since (binary operator) Once (unary operator) Historically (unary operator) To combine the above using boolean connectives, you can use the classes in pylogics.syntax.base described above.","title":"Past Linear Temporal Logic"},{"location":"syntax/#linear-dynamic-temporal-logic","text":"For LDL, you can use the following classes, defined in pylogics.syntax.ldl : LDLTrue , the boolean positive constant tt LDLFalse , the boolean negative constant ff Diamond(regex, ldlf_formula) Box(regex, ldlf_formula) To combine the above using boolean connectives, you can use the classes in pylogics.syntax.base described above. To build regular expressions: Prop(propositional) , where propositional is a propositional formula (i.e. propositional.logic is Logic.PL ) Union (binary operator) Seq (binary operator) Test(ldlf_formula) (unary operator) Star(regex) (unary operator)","title":"Linear Dynamic Temporal Logic"}]}